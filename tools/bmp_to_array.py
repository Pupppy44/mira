# mira/tools/bmp_to_array.py
# ? Converts BMP files to 256-color indexed C arrays for Mira

from PIL import Image
import numpy as np
import glob
import os
import threading

# VGA 256 color palette
palette = [
    (0x00, 0x00, 0x00), (0x00, 0x00, 0xAA), (0x00, 0xAA, 0x00), (0x00, 0xAA, 0xAA),
    (0xAA, 0x00, 0x00), (0xAA, 0x00, 0xAA), (0xAA, 0x55, 0x00), (0xAA, 0xAA, 0xAA),
    (0x55, 0x55, 0x55), (0x55, 0x55, 0xFF), (0x55, 0xFF, 0x55), (0x55, 0xFF, 0xFF),
    (0xFF, 0x55, 0x55), (0xFF, 0x55, 0xFF), (0xFF, 0xFF, 0x55), (0xFF, 0xFF, 0xFF),
    (0x00, 0x00, 0x00), (0x10, 0x10, 0x10), (0x20, 0x20, 0x20), (0x35, 0x35, 0x35),
    (0x45, 0x45, 0x45), (0x55, 0x55, 0x55), (0x65, 0x65, 0x65), (0x75, 0x75, 0x75),
    (0x8A, 0x8A, 0x8A), (0x9A, 0x9A, 0x9A), (0xAA, 0xAA, 0xAA), (0xBA, 0xBA, 0xBA),
    (0xCA, 0xCA, 0xCA), (0xDF, 0xDF, 0xDF), (0xEF, 0xEF, 0xEF), (0xFF, 0xFF, 0xFF),
    (0x00, 0x00, 0xFF), (0x41, 0x00, 0xFF), (0x82, 0x00, 0xFF), (0xBE, 0x00, 0xFF),
    (0xFF, 0x00, 0xFF), (0xFF, 0x00, 0xBE), (0xFF, 0x00, 0x82), (0xFF, 0x00, 0x41),
    (0xFF, 0x00, 0x00), (0xFF, 0x41, 0x00), (0xFF, 0x82, 0x00), (0xFF, 0xBE, 0x00),
    (0xFF, 0xFF, 0x00), (0xBE, 0xFF, 0x00), (0x82, 0xFF, 0x00), (0x41, 0xFF, 0x00),
    (0x00, 0xFF, 0x00), (0x00, 0xFF, 0x41), (0x00, 0xFF, 0x82), (0x00, 0xFF, 0xBE),
    (0x00, 0xFF, 0xFF), (0x00, 0xBE, 0xFF), (0x00, 0x82, 0xFF), (0x00, 0x41, 0xFF),
    (0x82, 0x82, 0xFF), (0x9E, 0x82, 0xFF), (0xBE, 0x82, 0xFF), (0xDF, 0x82, 0xFF),
    (0xFF, 0x82, 0xFF), (0xFF, 0x82, 0xDF), (0xFF, 0x82, 0xBE), (0xFF, 0x82, 0x9E),
    (0xFF, 0x82, 0x82), (0xFF, 0x9E, 0x82), (0xFF, 0xBE, 0x82), (0xFF, 0xDF, 0x82),
    (0xFF, 0xFF, 0x82), (0xDF, 0xFF, 0x82), (0xBE, 0xFF, 0x82), (0x9E, 0xFF, 0x82),
    (0x82, 0xFF, 0x82), (0x82, 0xFF, 0x9E), (0x82, 0xFF, 0xBE), (0x82, 0xFF, 0xDF),
    (0x82, 0xFF, 0xFF), (0x82, 0xDF, 0xFF), (0x82, 0xBE, 0xFF), (0x82, 0x9E, 0xFF),
    (0xBA, 0xBA, 0xFF), (0xCA, 0xBA, 0xFF), (0xDF, 0xBA, 0xFF), (0xEF, 0xBA, 0xFF),
    (0xFF, 0xBA, 0xFF), (0xFF, 0xBA, 0xEF), (0xFF, 0xBA, 0xDF), (0xFF, 0xBA, 0xCA),
    (0xFF, 0xBA, 0xBA), (0xFF, 0xCA, 0xBA), (0xFF, 0xDF, 0xBA), (0xFF, 0xEF, 0xBA),
    (0xFF, 0xFF, 0xBA), (0xEF, 0xFF, 0xBA), (0xDF, 0xFF, 0xBA), (0xCA, 0xFF, 0xBA),
    (0xBA, 0xFF, 0xBA), (0xBA, 0xFF, 0xCA), (0xBA, 0xFF, 0xDF), (0xBA, 0xFF, 0xEF),
    (0xBA, 0xFF, 0xFF), (0xBA, 0xEF, 0xFF), (0xBA, 0xDF, 0xFF), (0xBA, 0xCA, 0xFF),
    (0x00, 0x00, 0x71), (0x1C, 0x00, 0x71), (0x39, 0x00, 0x71), (0x55, 0x00, 0x71),
    (0x71, 0x00, 0x71), (0x71, 0x00, 0x55), (0x71, 0x00, 0x39), (0x71, 0x00, 0x1C),
    (0x71, 0x00, 0x00), (0x71, 0x1C, 0x00), (0x71, 0x39, 0x00), (0x71, 0x55, 0x00),
    (0x71, 0x71, 0x00), (0x55, 0x71, 0x00), (0x39, 0x71, 0x00), (0x1C, 0x71, 0x00),
    (0x00, 0x71, 0x00), (0x00, 0x71, 0x1C), (0x00, 0x71, 0x39), (0x00, 0x71, 0x55),
    (0x00, 0x71, 0x71), (0x00, 0x55, 0x71), (0x00, 0x39, 0x71), (0x00, 0x1C, 0x71),
    (0x39, 0x39, 0x71), (0x45, 0x39, 0x71), (0x55, 0x39, 0x71), (0x61, 0x39, 0x71),
    (0x71, 0x39, 0x71), (0x71, 0x39, 0x61), (0x71, 0x39, 0x55), (0x71, 0x39, 0x45),
    (0x71, 0x39, 0x39), (0x71, 0x45, 0x39), (0x71, 0x55, 0x39), (0x71, 0x61, 0x39),
    (0x71, 0x71, 0x39), (0x61, 0x71, 0x39), (0x55, 0x71, 0x39), (0x45, 0x71, 0x39),
    (0x39, 0x71, 0x39), (0x39, 0x71, 0x45), (0x39, 0x71, 0x55), (0x39, 0x71, 0x61),
    (0x39, 0x71, 0x71), (0x39, 0x61, 0x71), (0x39, 0x55, 0x71), (0x39, 0x45, 0x71),
    (0x51, 0x51, 0x71), (0x59, 0x51, 0x71), (0x61, 0x51, 0x71), (0x69, 0x51, 0x71),
    (0x71, 0x51, 0x71), (0x71, 0x51, 0x69), (0x71, 0x51, 0x61), (0x71, 0x51, 0x59),
    (0x71, 0x51, 0x51), (0x71, 0x59, 0x51), (0x71, 0x61, 0x51), (0x71, 0x69, 0x51),
    (0x71, 0x71, 0x51), (0x69, 0x71, 0x51), (0x61, 0x71, 0x51), (0x59, 0x71, 0x51),
    (0x51, 0x71, 0x51), (0x51, 0x71, 0x59), (0x51, 0x71, 0x61), (0x51, 0x71, 0x69),
    (0x51, 0x71, 0x71), (0x51, 0x69, 0x71), (0x51, 0x61, 0x71), (0x51, 0x59, 0x71),
    (0x00, 0x00, 0x41), (0x10, 0x00, 0x41), (0x20, 0x00, 0x41), (0x31, 0x00, 0x41),
    (0x41, 0x00, 0x41), (0x41, 0x00, 0x31), (0x41, 0x00, 0x20), (0x41, 0x00, 0x10),
    (0x41, 0x00, 0x00), (0x41, 0x10, 0x00), (0x41, 0x20, 0x00), (0x41, 0x31, 0x00),
    (0x41, 0x41, 0x00), (0x31, 0x41, 0x00), (0x20, 0x41, 0x00), (0x10, 0x41, 0x00),
    (0x00, 0x41, 0x00), (0x00, 0x41, 0x10), (0x00, 0x41, 0x20), (0x00, 0x41, 0x31),
    (0x00, 0x41, 0x41), (0x00, 0x31, 0x41), (0x00, 0x20, 0x41), (0x00, 0x10, 0x41),
    (0x20, 0x20, 0x41), (0x28, 0x20, 0x41), (0x31, 0x20, 0x41), (0x39, 0x20, 0x41),
    (0x41, 0x20, 0x41), (0x41, 0x20, 0x39), (0x41, 0x20, 0x31), (0x41, 0x20, 0x28),
    (0x41, 0x20, 0x20), (0x41, 0x28, 0x20), (0x41, 0x31, 0x20), (0x41, 0x39, 0x20),
    (0x41, 0x41, 0x20), (0x39, 0x41, 0x20), (0x31, 0x41, 0x20), (0x28, 0x41, 0x20),
    (0x20, 0x41, 0x20), (0x20, 0x41, 0x28), (0x20, 0x41, 0x31), (0x20, 0x41, 0x39),
    (0x20, 0x41, 0x41), (0x20, 0x39, 0x41), (0x20, 0x31, 0x41), (0x20, 0x28, 0x41),
    (0x2D, 0x2D, 0x41), (0x31, 0x2D, 0x41), (0x35, 0x2D, 0x41), (0x3D, 0x2D, 0x41),
    (0x41, 0x2D, 0x41), (0x41, 0x2D, 0x3D), (0x41, 0x2D, 0x35), (0x41, 0x2D, 0x31),
    (0x41, 0x2D, 0x2D), (0x41, 0x31, 0x2D), (0x41, 0x35, 0x2D), (0x41, 0x3D, 0x2D),
    (0x41, 0x41, 0x2D), (0x3D, 0x41, 0x2D), (0x35, 0x41, 0x2D), (0x31, 0x41, 0x2D),
    (0x2D, 0x41, 0x2D), (0x2D, 0x41, 0x31), (0x2D, 0x41, 0x35), (0x2D, 0x41, 0x3D),
    (0x2D, 0x41, 0x41), (0x2D, 0x3D, 0x41), (0x2D, 0x35, 0x41), (0x2D, 0x31, 0x41),
    (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
    (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00)
]

def find_matching_palette_color(pixel):
    r, g, b = pixel
    for i, (pr, pg, pb) in enumerate(palette):
        if r == pr and g == pg and b == pb:
            return i
    # Estimate closest color if no exact match
    return find_closest_palette_color(pixel)

# If we can't find an exact match, find the closest color in the palette
def find_closest_palette_color(pixel):
    r, g, b = pixel
    min_dist = float('inf')
    closest_index = 0
    for i, (pr, pg, pb) in enumerate(palette):
        dist = (r - pr) ** 2 + (g - pg) ** 2 + (b - pb) ** 2
        if dist < min_dist:
            min_dist = dist
            closest_index = i
    return closest_index

def bmp_to_c_array(image_path):
    img = Image.open(image_path).convert('RGB', palette=Image.ADAPTIVE, colors=256)
    pixels = np.array(img)
    height, width, _ = pixels.shape
    c_array = []

    for y in range(height):
        row = []
        for x in range(width):
            pixel = pixels[y, x]
            index = find_matching_palette_color(pixel)
            row.append(index)
        c_array.append(row)

    return c_array

def save_c_array_to_file(c_array, file_path):
    array_name = os.path.splitext(os.path.basename(file_path))[0]
    with open(file_path, 'w') as f:
        f.write("#include <stdint.h>\n\n")
        f.write("#define " + array_name.upper() + "_WIDTH " + str(len(c_array[0])) + "\n")
        f.write("#define " + array_name.upper() + "_HEIGHT " + str(len(c_array)) + "\n\n")
        f.write("static uint8_t " + array_name + "[] = {")
        for row in c_array:
            for index in row:
                f.write(f"{index}, ")
        f.write("};")
    
    print(f"Saved {file_path}")

if __name__ == "__main__":
    bmp_files = glob.glob('../assets/*.bmp')
    print("# of bmp files found:", len(bmp_files))
    print("Now converting to C arrays...")

    def process_bmp_file(bmp_file):
        c_array = bmp_to_c_array(bmp_file)
        header_file = os.path.splitext(bmp_file)[0] + '.h'
        save_c_array_to_file(c_array, header_file)

    # Use threading to speed up the process for multiple files
    threads = []
    for bmp_file in bmp_files:
        thread = threading.Thread(target=process_bmp_file, args=(bmp_file,))
        threads.append(thread)
        thread.start()

    for thread in threads:
        thread.join()